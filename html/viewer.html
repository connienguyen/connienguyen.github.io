<!DOCTYPE html>
<html lang="en">
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>Underground Viewer</title>
		<!-- library setup -->
		<script src="../js/three.min.js"></script>
		<script src="../js/ar.min2.js"></script>
		<script>THREEx.ArToolkitContext.baseURL = "../"</script>
		<script src="/js/jquery-3.3.1.min.js"></script>
	</head>
	<body style="margin: 0px; overflow: hidden; font-family: Monospace;">
		<script>
			// initialize renderer
			var renderer = new THREE.WebGLRenderer({
				antialias: true,
				alpha: true
			});
			renderer.setClearColor(new THREE.Color('lightgrey'), 0)
			renderer.setSize(640,480);
			renderer.domElement.style.position = 'absolute';
			renderer.domElement.style.top = '0px';
			renderer.domElement.style.left = '0px';
			document.body.appendChild(renderer.domElement);

			// array of function for the rendering loop
			var onRenderFcts = [];

			// init scene and camera
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
			scene.add(camera);

			// handle arToolkitSource
			var arToolkitSource = new THREEx.ArToolkitSource({
				sourceType: 'webcam'
			});

			arToolkitSource.init(function onReady() {
				onResize();
			});

			// handle window resize
			window.addEventListener('resize', function() {
				onResize();
			});

			function onResize() {
				arToolkitSource.onResizeElement();
				arToolkitSource.copySizeTo(renderer.domElement);
				if ( arToolkitSource.arController !== null ) {
					arToolkitSource.copySizeTo(arToolkitContext.arController.canvas);
				}
			}

			// initialize arToolkitContext
			var arToolkitContext = new THREEx.ArToolkitContext({
				cameraParametersUrl: THREEx.ArToolkitContext.baseURL + 'data/camera_para.dat',
				detectionMode: 'mono'
			});

			arToolkitContext.init(function onCompleted() {
				camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
			});

			// update arToolkit on every frame
			onRenderFcts.push(function() {
				if ( arToolkitSource.ready === false ) return;

				arToolkitContext.update(arToolkitSource.domElement);
				scene.visible = camera.visible;
			});

			// functions/models for common use
			var _normalMaterial = new THREE.MeshNormalMaterial({
				transparent: true,
				side: THREE.BackSide
			})

			function createInnerMesh() {
				var cubeGeometry = new THREE.CubeGeometry(1,1,1);
				var cubeMesh = new THREE.Mesh(cubeGeometry, _normalMaterial);
				cubeMesh.name = 'inner';
				return cubeMesh;
			}

			function createInvisibleMesh() {
				var invisibleGeometry = new THREE.BoxGeometry(1,1,1);
				invisibleGeometry.faces.splice(8,2); // Use plane instead?
				var invisibleMaterial = new THREE.MeshBasicMaterial({
					colorWrite: false
				})
				var invisibleMesh = new THREE.Mesh(invisibleGeometry, invisibleMaterial);
				invisibleMesh.scale.setX(1.03);
				invisibleMesh.scale.setY(1.03);
				invisibleMesh.scale.setZ(1.03);
				//invisibleMesh.scale.set(1,1,1).multiplyScalar(1.03);
				return invisibleMesh;
			}

			// create marker roots
			var angardsMarker = new THREE.Group;
			angardsMarker.name = 'angards';
			scene.add(angardsMarker);

			var lillaMarker = new THREE.Group;
			lillaMarker.name = 'lilla';
			scene.add(lillaMarker);

			var linneMarker = new THREE.Group;
			linneMarker.name = 'linne';
			scene.add(linneMarker);

			var mastMarker = new THREE.Group;
			mastMarker.name = 'mast';
			scene.add(mastMarker);

			// Add patters for markers
			var _ = new THREEx.ArMarkerControls(arToolkitContext, angardsMarker, {
				type: 'pattern',
				patternUrl: THREEx.ArToolkitContext.baseURL + 'data/angards.patt'
			});
			var _ = new THREEx.ArMarkerControls(arToolkitContext, lillaMarker, {
				type: 'pattern',
				patternUrl: THREEx.ArToolkitContext.baseURL + 'data/lilla.patt'
			});	
			var _ = new THREEx.ArMarkerControls(arToolkitContext, linneMarker, {
				type: 'pattern',
				patternUrl: THREEx.ArToolkitContext.baseURL + 'data/linne.patt'
			});	
			var _ = new THREEx.ArMarkerControls(arToolkitContext, mastMarker, {
				type: 'pattern',
				patternUrl: THREEx.ArToolkitContext.baseURL + 'data/mast.patt'
			});		

			// Create cube group for all makers
			var markerRoots = scene.children.filter(child => child.type == 'Group');
			var textureLoader = new THREE.TextureLoader();

			markerRoots.forEach(function (marker) {
				var innerMesh = createInnerMesh();
				var cubeGroup = new THREE.Group;
				cubeGroup.scale.set(1,1,1).multiplyScalar(1.2);
				cubeGroup.rotation.x = -Math.PI/2;
				cubeGroup.position.y = -cubeGroup.scale.x/2;
				marker.add(cubeGroup);
				var invisibleMesh = createInvisibleMesh();
				cubeGroup.add(invisibleMesh);
				cubeGroup.add(innerMesh);
			});

			textureLoader.load(
				THREEx.ArToolkitContext.baseURL + 'data/earthy_texture.jpg',
				function (texture) {
					var textureMaterial = new THREE.MeshBasicMaterial({
						map: texture,
						side: THREE.BackSide
					});
					markerRoots.forEach(function(marker) {
						var innerArr = marker.children[0].children.filter(mesh => mesh.name == 'inner');
						if (innerArr.length > 0) {
							var inner = innerArr[0];
							inner.material = textureMaterial;
						}
					});
				},
				undefined,
				function (err) {
					console.log('Texture loader error: ', err);
				}
			)

			// Load objects for different models
			// FIXME: Strange glitch where invisible box does not work if one loader is used for multiple models
			var angardsLoader = new THREE.ObjectLoader();
			angardsLoader.load(
				THREEx.ArToolkitContext.baseURL + 'data/building.json', loadedAngards
			);

			var lillaLoader = new THREE.ObjectLoader();
			lillaLoader.load(
				THREEx.ArToolkitContext.baseURL + 'data/tunnel.json', loadedLilla
			);


			var linneLoader = new THREE.ObjectLoader();
			linneLoader.load(
				THREEx.ArToolkitContext.baseURL + 'data/river.json', loadedLinne
			);

			var mastLoader = new THREE.ObjectLoader();
			mastLoader.load(
				THREEx.ArToolkitContext.baseURL + 'data/tunnel-2.json', loadedMast
			);


			function loadedAngards(obj) {
				var angardsCubeGroup = null;
				if (angardsMarker.children.length > 0) {
					angardsCubeGroup = angardsMarker.children[0];
				}	
				var pointLight = new THREE.PointLight( 0xe6f2ff );
				pointLight.position.set(0, -0.8, 0);
				obj.scale.setScalar(0.2, 0.2, 0.2);
				obj.scale.setY(0.3);
				obj.position.z = 0.1;
				obj.rotation.x = Math.PI/2;
				angardsCubeGroup.add(obj);
				angardsCubeGroup.add(pointLight);
			}

			function loadedLilla(obj) {
				var lillaCubeGroup = lillaMarker.children[0];
				if (!lillaCubeGroup) {
					return;
				}
				var pointLight = new THREE.PointLight( 0xe6f2ff );
				pointLight.position.set(0.4, 1, 0.75);
				obj.scale.setScalar(0.12, 0.12, 0.12);
				obj.position.x = -0.2;
				obj.position.y = -0.66;
				obj.position.z = 0.5;
				obj.rotation.y = -Math.PI/2;
				lillaCubeGroup.add(obj);
				lillaCubeGroup.add(pointLight);
			}

			function loadedLinne(obj) {
				var linneCubeGroup = null;
				if (linneMarker.children.length > 0) {
					linneCubeGroup = linneMarker.children[0];
				}

				var waterMaterial = new THREE.MeshStandardMaterial({
					color: 0x263c50,
					metalness: 0.7,
					roughness: 0.3
				});
				var pointLight = new THREE.PointLight( 0xe6f2ff );
				pointLight.position.set(0.4, 1, 2.75);
				var waterMaterial = new THREE.MeshStandardMaterial({
					color: 0x263c50,
					metalness: 0.7,
					roughness: 0.3
				});
				obj.scale.setX(0.005);
				obj.scale.setY(0.001);
				obj.scale.setZ(0.00165);
				obj.rotation.x = Math.PI/2;
				obj.children.forEach(function (child) {
					if (child instanceof THREE.Mesh) {
						child.material = waterMaterial;
					}
					linneLight = pointLight;
					linneCubeGroup.add(obj);
					linneCubeGroup.add(pointLight);
				})
			}

			function loadedMast(obj) {
				var mastCubeGroup = mastMarker.children[0];
				if (!mastCubeGroup) {
					return;
				}

				var lambert = new THREE.MeshLambertMaterial({
					color: 0x5c666b,
					side: THREE.DoubleSide
				});
				var pointLight = new THREE.PointLight( 0xe6f2ff );
				pointLight.position.set(0.4, 1, 0.75);
				obj.scale.setScalar(0.07, 0.07, 0.07);
				obj.scale.setX(0.1);
				obj.position.y = -0.1;
				obj.position.z = -0.1;
				obj.rotation.y = -Math.PI/2;
				obj.children.forEach(function (child) {
					if (child instanceof THREE.Mesh) {
						child.material = lambert;
					}
				})
				mastCubeGroup.add(pointLight);
				mastTunnel = obj;
				mastCubeGroup.add(obj);
			}

			// Load teapot for inside of cube
			var teaMesh = null;
			var objectLoader = new THREE.ObjectLoader();
			var lambert = new THREE.MeshLambertMaterial({
				color: 0x5c666b,
				side: THREE.DoubleSide
			});

			function animateBobbing(mesh, t) {
				mesh.position.z = 0.4*Math.sin(t) + 0.2;
			}

			function moveLight(light, t) {
				light.position.x = 1.2 * Math.cos( t );
				light.position.y = 1.2* Math.sin( t );
			}
 
			var t = 0;
			var linneLight;
			var mastTunnel;
			onRenderFcts.push(function (delta) {
				t+= delta;
				moveLight(linneLight, t);
				animateBobbing(mastTunnel, t);
			})


			// Visibility detector
			var markers = scene.children.filter(child => child.type == 'Group');
			var markerVisibility = {};
			markers.forEach(function(marker) {
				markerVisibility[marker.uuid] = marker.visible;
			});

			function onMarkerVisible(marker) {
				console.log('Now visible ' + marker.uuid + ' ' + marker.name);
			}

			function checkVisibility() {
				markers.forEach(function (marker) {
					if (markerVisibility[marker.uuid] !== marker.visible) {
						// Change in visibility
						markerVisibility[marker.uuid] = marker.visible
						if ( marker.visible) onMarkerVisible(marker);
					}
				});
			}

			onRenderFcts.push(function (_) { checkVisibility(); });

			// render the scene
			onRenderFcts.push(function() {
				renderer.render(scene, camera);
			});

			// run rendering loop
			var lastTimeMsec = null;
			requestAnimationFrame(function animate(nowMsec) {
				requestAnimationFrame(animate);

				lastTimeMsec = lastTimeMsec || nowMsec - 1000/60;
				var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
				lastTimeMsec = nowMsec;

				onRenderFcts.forEach(function (onRenderFct) {
					onRenderFct(deltaMsec/1000, nowMsec/1000);
				});
			})
		</script>
	</body>
</html>